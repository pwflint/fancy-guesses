[
  {
    "objectID": "beginnings.html",
    "href": "beginnings.html",
    "title": "Beginnings",
    "section": "",
    "text": "This a collection of early reflections and tutorials I found helpful as I started learning data science. A comprehensive list of all resources is included on the bookmarks page. The early stages of of this project are focused on creating personal accountability in distilling my notes into coherent thoughts.\nMore options for how list pages work can be found here.\nOverview for post directory is here.\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n     \n  \n\n\n\n\n\n\n\n\nPlaying With Ambient\n\n\n\nspatial\n\n\ngenerativeRt\n\n\n\n\n\n\n\nPeter W. Flint\n\n\n\n\n\n\n\n\n\n\n\n\nBeginnings\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFancy Guesses\n\n\n\n\n\n\nPeter W. Flint\n\n\n\n\n\n\n\n\n\n\n\n\nAbout\n\n\n\n\n\n\nPeter W. Flint\n\n\n\n\n\n\n\n\n\n\n\n\nBookmarks\n\n\n\n\n\n\nPeter W. Flint\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Why do data science? My only excuse is that I stumbled into it accidentally. Several years ago I was taking an introductory course in GIS applications (I like maps), and my final project was to select an example map and create a walkthrough to recreate it. I chose the abundance maps developed by eBird (I also like birds).\n\n\n\nThe relative abundance of Blue-Headed Vireos, an inquisitive bird of summertime.\n\n\nIt turns out, these maps are generated with R, a statistical computing language, and not a GIS, so I redirected. But I had now discovered data science.\nData science is fucking hard. You have to learn programming. Then you have to learn statistics. Then you have to learn about bias. Then you have to learn best practices to avoid bias. Then you have to embark on an inward journey of the soul to investigate the source of your own implicit biases, identifying and eradicating fundamental parts of your established self-concept, and after several years of this and some complementary therapy, some janky fucking histogram is the best you can produce. Then you have to learn web design so you can publish your janky histogram.\n\nWerner Herzog\nFacts do not illuminate us.\n\nBut in the process of all of this I’ve developed a real appreciation for the folks who manipulate and use data to communicate on a daily basis, and its contribution to how we understand ourselves and the world in which we live. Werner Herzog has an interesting perspective on facts. He says, “Facts do not illuminate us.”\nA data point is a fact, and a data set illustrates a trend, but it is up to us to translate the “facts” into a “story,” and stories transcend facts. A story is data arranged into Meaning. The scientific method prescribes that we approach the world with ambiguity, and this is largely useful. But it does not inspire us to incorporate new knowledge into our lives joyfully and creatively. Data can help tell a story, and the story invites us to consider how facts might contribute to new possibilities.\nI adhere to the principle that publicly practiced science has greater epistemic authority. That said, I am not a formally trained data scientist, or any other kind of scientist. My interest in this field stems from a commitment to the craft of landscape design. To me, craft is the synthesis of art and science. Art informs creative freedom, science informs the limitations within which art is expressed. Much of what is popularly believed about landscapes is not scientifically derived. Ecosystems do not respond obediently methods of control. It is ultimately my hope to use data to illustrate the complexity informing the aesthetic appeal of wild beauty. This is the scientific component. It informs the limitations from which the artistic component emerges."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Fancy Guesses",
    "section": "",
    "text": "Hello.\nThis is an amateur exploration of data science, what I refer to as “the Art of making Fancy Guesses.” It is a playful approach to a difficult subject. I want to understand how data is obtained and organized before it is distilled into a communication artifact. It has been observed that the obsolescence of computation by hand in the financial sector may have contributed to the decline of its operational capacity and managerial competence. I think a similar argument can be made for how we engage with data. Understanding the process by which it is obtained, interpreted, and distilled equips us to better evaluate its quality and relevance.\nThere is a creative tension between education for the sake of private business goals and curating knowledge for general use. I believe a business should always orient its training around organization -specific workflows but should provide resources and arguments about why that specific workflow is used. The pitfall of workflow-specific training is that it tends to lose philosophical relevance over time as the procedures are passed down to subsequent generations of workers, and are iterated over as they adapt to changing technology. After a few years, the reasoning behind certain methods becomes lost and it is simply “the way its always been done.” This eventually stifles innovation in the workflow. Maintaining awareness of principles behind tools and practices helps with adaptations to new circumstances over time.\nYou can learn more about the history of this project here."
  },
  {
    "objectID": "index.html#welcome",
    "href": "index.html#welcome",
    "title": "Fancy Guesses",
    "section": "",
    "text": "Hello.\nThis is an amateur exploration of data science, what I refer to as “the Art of making Fancy Guesses.” It is a playful approach to a difficult subject. I want to understand how data is obtained and organized before it is distilled into a communication artifact. It has been observed that the obsolescence of computation by hand in the financial sector may have contributed to the decline of its operational capacity and managerial competence. I think a similar argument can be made for how we engage with data. Understanding the process by which it is obtained, interpreted, and distilled equips us to better evaluate its quality and relevance.\nThere is a creative tension between education for the sake of private business goals and curating knowledge for general use. I believe a business should always orient its training around organization -specific workflows but should provide resources and arguments about why that specific workflow is used. The pitfall of workflow-specific training is that it tends to lose philosophical relevance over time as the procedures are passed down to subsequent generations of workers, and are iterated over as they adapt to changing technology. After a few years, the reasoning behind certain methods becomes lost and it is simply “the way its always been done.” This eventually stifles innovation in the workflow. Maintaining awareness of principles behind tools and practices helps with adaptations to new circumstances over time.\nYou can learn more about the history of this project here."
  },
  {
    "objectID": "bookmarks.html",
    "href": "bookmarks.html",
    "title": "Bookmarks",
    "section": "",
    "text": "Shattered Landscapes by Danielle Navarro"
  },
  {
    "objectID": "bookmarks.html#resources",
    "href": "bookmarks.html#resources",
    "title": "Bookmarks",
    "section": "",
    "text": "Shattered Landscapes by Danielle Navarro"
  },
  {
    "objectID": "posts/beginnings.html",
    "href": "posts/beginnings.html",
    "title": "Beginnings",
    "section": "",
    "text": "This a collection of early reflections and tutorials I found helpful as I started learning data science. A comprehensive list of all resources is included on the bookmarks page. The early stages of of this project are focused on creating personal accountability in distilling my notes into coherent thoughts.\nMore options for how list pages work can be found here.\nOverview for post directory is here.\n\n\n\n\n\n\n   \n     \n     \n       Order By\n       Default\n         \n          Title\n        \n     \n  \n\n\n\n\n\n\n\n\nPlaying With Ambient\n\n\n\nspatial\n\n\ngenerativeRt\n\n\n\n\n\n\n\nPeter W. Flint\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/shattered.html",
    "href": "posts/shattered.html",
    "title": "Playing With Ambient",
    "section": "",
    "text": "This is a walkthrough set up by Danielle Navarro, a data scientist with some interesting generative art work. The project explores the Rayshader and ambient packages to create and render conceptual topographies on a virtual canvas, then manipulating the data to create distortions in the contours. The process utilizes a simple grid built from the ambient::long-grid function, then assigns a color set to a function that generates spatial noise with the fracture, gen_simplex, and billow functions, based on a preset seed number. This can be randomly assigned using the sample function.\nThe first part of generating data frames and output is fairly straightforward and provides lots of opportunities to play with various arguments in each function. The process of creating fantasy landscapes is less interesting to me, but worthwhile in the practice of exploring new functions in depth.\nI’m am interested in both of these tool sets to see if they can be paired with spatial data objects to illustrate existing terrains.\n\n\n\n\n# Set seed seed &lt;- sample(1:100, 1)\n\n# Create the intial grid\n\nnew_grid &lt;- function(n = 1000) { ambient::long_grid( x = seq(0, 1, length.out = n), y = seq(0, 1, length.out = n) ) }\n\nnew_grid() \n\n# The output is a data frame with x/y coordinates\n# Create spatial noise. This breaks the grid into fractals and assigns a color for each value. It is currently unclear to me how this works. \n  generate_simplex &lt;- function(x, y, seed = NULL) {\n  if(!is.null(seed)) {\n    set.seed(seed)\n  }\n  ambient::fracture(\n    noise = ambient::gen_simplex,\n    fractal = ambient::billow,\n    octaves = 10,\n    freq_init = .02,\n    frequency = ~ . * 2,\n    gain_init = 1,\n    gain = ~ . * .8,\n    x = x,\n    y = y\n  )\n}\nIt is currently unclear to me how the fracture function assigns colors to the grid, whether that is within the noise or fractal arguments. The output (shown in next section) appears as a heat map with R to Y tones.\n# Create canvas. The mutate function adds a column 'paint' to the original new_grid() data frame. \n\ncanvas &lt;- new_grid() |&gt; dplyr::mutate(paint = generate_simplex(x, y, seed = seed))\n\ncanvas\n\n\n\n# Unsure about the function or necessity of this script. The object does appear in any future scripts and removing it does not affect the output.\nbitmap &lt;- canvas |&gt; as.array(value = paint)\nbitmap[1:6, 1:6]\n\n# This creates a plot using the as.array() function to map the values of `paint` on the new_grid dataframe. The image() function generates the output. The result is a 2d color rendering of the spatial noise generated by the generate_sinmplex function. \ncanvas |&gt;    as.array(value = paint) |&gt;   image(axes = FALSE, asp = 1, useRaster = TRUE) \n\n\n\nBasic map with ambient noise function.\n\n\n\n\n\n# This creates the parameters for rendering the image above in 3d. \nrender &lt;- function(mat, shades = NULL, zscale = .005) { \n  if(is.null(shades)) { \n    n &lt;- length(unique(mat)) \n    shades &lt;- hcl.colors(n, \"YlOrRd\", rev = TRUE) \n  } \n  rayshader::height_shade( \n    heightmap = mat, \n    texture = shades \n  ) \n  |&gt; rayshader::add_shadow( \n    shadowmap = rayshader::ray_shade( \n      heightmap = mat, \n      sunaltitude = 50, \n      sunangle = 80, \n      multicore = TRUE, \n      zscale = zscale ), \n    max_darken = .2 \n  ) \n  |&gt; rayshader::plot_map() \n}\n\n# This generates the output\n\ncanvas |&gt; as.array(value = paint) |&gt; render()\n\n\n\nThe rendered output using `Rayshader`\n\n\n# sea_level creates a datum that cuts off at the median value of the 'paint' column\nsea_level &lt;- median(canvas$paint)\n\n# The sea_level datum can be added to the canvas to create islands. This creates an 'islaands' column and sets its value to either sea_level or paint, whichever is higher. \ncanvas |&gt; \n  dplyr::mutate(\n    islands = dplyr::if_else(\n      condition = paint &lt; sea_level,\n      true = sea_level, \n      false = paint\n    )\n  ) |&gt;\n  as.array(value = islands) |&gt;\n  render()\n You could stop here and play with various arguments for a little while to see how each function works.\n\n\n\nThis manipulates the spatial noise generator by combining the primary noise functions in ambient::fracture with ambient::gen_worley. The result feels like sub-ducted geography as opposed to volcanic.\ngenerate_fancy_noise &lt;- function(x, y, seed = NULL) { \n  if(!is.null(seed)) { \n    set.seed(seed) \n  } \n  z &lt;- ambient::fracture(\n    noise = ambient::gen_worley, \n    fractal = ambient::billow, \n    octaves = 8, freq_init = .1, \n    frequency = ~ . * 2, \n    gain_init = 3, \n    gain = ~ . * .5, \n    value = \"distance2\", \n    x = x, \n    y = y \n  ) \n  ambient::fracture( \n    noise = ambient::gen_simplex, \n    fractal = ambient::billow, \n    octaves = 10, \n    freq_init = .02, \n    frequency = ~ . * 2, \n    gain_init = 1, \n    gain = ~ . * .8, \n    x = x + z, \n    y = y + z \n  ) \n}\n\nnew_grid() |&gt; dplyr::mutate( \n  height = generate_fancy_noise(x, y, seed = seed), \n  islands = dplyr::if_else( \n    condition = height &lt; median(height), \n    true = median(height), \n    false = height \n    ) \n  ) |&gt; as.array(value = islands) |&gt; \n  render(zscale = .01) \n\n\n\nThe ‘shattered’ landscape.\n\n\nAdditional scripts are in the project folder and utilize some interesting functions such as curl fields and curl transformations that use a discretize() function to create a terracing effect. Much of the output looks like code going through puberty, awkward and unclear as to its outcome. Additoinally, there are some examples of creating different color palettes than the default YlOrRd being used by the native functions in the code. My final output looked like this:\n\n\n\n‘Queered’ geography."
  },
  {
    "objectID": "posts/shattered.html#playing-with-ambient",
    "href": "posts/shattered.html#playing-with-ambient",
    "title": "Playing With Ambient",
    "section": "",
    "text": "This is a walkthrough set up by Danielle Navarro, a data scientist with some interesting generative art work. The project explores the Rayshader and ambient packages to create and render conceptual topographies on a virtual canvas, then manipulating the data to create distortions in the contours. The process utilizes a simple grid built from the ambient::long-grid function, then assigns a color set to a function that generates spatial noise with the fracture, gen_simplex, and billow functions, based on a preset seed number. This can be randomly assigned using the sample function.\nThe first part of generating data frames and output is fairly straightforward and provides lots of opportunities to play with various arguments in each function. The process of creating fantasy landscapes is less interesting to me, but worthwhile in the practice of exploring new functions in depth.\nI’m am interested in both of these tool sets to see if they can be paired with spatial data objects to illustrate existing terrains.\n\n\n\n\n# Set seed seed &lt;- sample(1:100, 1)\n\n# Create the intial grid\n\nnew_grid &lt;- function(n = 1000) { ambient::long_grid( x = seq(0, 1, length.out = n), y = seq(0, 1, length.out = n) ) }\n\nnew_grid() \n\n# The output is a data frame with x/y coordinates\n# Create spatial noise. This breaks the grid into fractals and assigns a color for each value. It is currently unclear to me how this works. \n  generate_simplex &lt;- function(x, y, seed = NULL) {\n  if(!is.null(seed)) {\n    set.seed(seed)\n  }\n  ambient::fracture(\n    noise = ambient::gen_simplex,\n    fractal = ambient::billow,\n    octaves = 10,\n    freq_init = .02,\n    frequency = ~ . * 2,\n    gain_init = 1,\n    gain = ~ . * .8,\n    x = x,\n    y = y\n  )\n}\nIt is currently unclear to me how the fracture function assigns colors to the grid, whether that is within the noise or fractal arguments. The output (shown in next section) appears as a heat map with R to Y tones.\n# Create canvas. The mutate function adds a column 'paint' to the original new_grid() data frame. \n\ncanvas &lt;- new_grid() |&gt; dplyr::mutate(paint = generate_simplex(x, y, seed = seed))\n\ncanvas\n\n\n\n# Unsure about the function or necessity of this script. The object does appear in any future scripts and removing it does not affect the output.\nbitmap &lt;- canvas |&gt; as.array(value = paint)\nbitmap[1:6, 1:6]\n\n# This creates a plot using the as.array() function to map the values of `paint` on the new_grid dataframe. The image() function generates the output. The result is a 2d color rendering of the spatial noise generated by the generate_sinmplex function. \ncanvas |&gt;    as.array(value = paint) |&gt;   image(axes = FALSE, asp = 1, useRaster = TRUE) \n\n\n\nBasic map with ambient noise function.\n\n\n\n\n\n# This creates the parameters for rendering the image above in 3d. \nrender &lt;- function(mat, shades = NULL, zscale = .005) { \n  if(is.null(shades)) { \n    n &lt;- length(unique(mat)) \n    shades &lt;- hcl.colors(n, \"YlOrRd\", rev = TRUE) \n  } \n  rayshader::height_shade( \n    heightmap = mat, \n    texture = shades \n  ) \n  |&gt; rayshader::add_shadow( \n    shadowmap = rayshader::ray_shade( \n      heightmap = mat, \n      sunaltitude = 50, \n      sunangle = 80, \n      multicore = TRUE, \n      zscale = zscale ), \n    max_darken = .2 \n  ) \n  |&gt; rayshader::plot_map() \n}\n\n# This generates the output\n\ncanvas |&gt; as.array(value = paint) |&gt; render()\n\n\n\nThe rendered output using `Rayshader`\n\n\n# sea_level creates a datum that cuts off at the median value of the 'paint' column\nsea_level &lt;- median(canvas$paint)\n\n# The sea_level datum can be added to the canvas to create islands. This creates an 'islaands' column and sets its value to either sea_level or paint, whichever is higher. \ncanvas |&gt; \n  dplyr::mutate(\n    islands = dplyr::if_else(\n      condition = paint &lt; sea_level,\n      true = sea_level, \n      false = paint\n    )\n  ) |&gt;\n  as.array(value = islands) |&gt;\n  render()\n You could stop here and play with various arguments for a little while to see how each function works.\n\n\n\nThis manipulates the spatial noise generator by combining the primary noise functions in ambient::fracture with ambient::gen_worley. The result feels like sub-ducted geography as opposed to volcanic.\ngenerate_fancy_noise &lt;- function(x, y, seed = NULL) { \n  if(!is.null(seed)) { \n    set.seed(seed) \n  } \n  z &lt;- ambient::fracture(\n    noise = ambient::gen_worley, \n    fractal = ambient::billow, \n    octaves = 8, freq_init = .1, \n    frequency = ~ . * 2, \n    gain_init = 3, \n    gain = ~ . * .5, \n    value = \"distance2\", \n    x = x, \n    y = y \n  ) \n  ambient::fracture( \n    noise = ambient::gen_simplex, \n    fractal = ambient::billow, \n    octaves = 10, \n    freq_init = .02, \n    frequency = ~ . * 2, \n    gain_init = 1, \n    gain = ~ . * .8, \n    x = x + z, \n    y = y + z \n  ) \n}\n\nnew_grid() |&gt; dplyr::mutate( \n  height = generate_fancy_noise(x, y, seed = seed), \n  islands = dplyr::if_else( \n    condition = height &lt; median(height), \n    true = median(height), \n    false = height \n    ) \n  ) |&gt; as.array(value = islands) |&gt; \n  render(zscale = .01) \n\n\n\nThe ‘shattered’ landscape.\n\n\nAdditional scripts are in the project folder and utilize some interesting functions such as curl fields and curl transformations that use a discretize() function to create a terracing effect. Much of the output looks like code going through puberty, awkward and unclear as to its outcome. Additoinally, there are some examples of creating different color palettes than the default YlOrRd being used by the native functions in the code. My final output looked like this:\n\n\n\n‘Queered’ geography."
  },
  {
    "objectID": "posts/shattered.html#resources",
    "href": "posts/shattered.html#resources",
    "title": "Playing With Ambient",
    "section": "Resources",
    "text": "Resources\n\nFull text of the tutorial.\nFull script for creating islands."
  },
  {
    "objectID": "posts/shattered.html#references",
    "href": "posts/shattered.html#references",
    "title": "Playing With Ambient",
    "section": "References",
    "text": "References\n\nNavarro, Danielle. 2023. “Shattered Landscapes.” March 13, 2023. https://blog.djnavarro.net/posts/2023-03-13_shattered-landscapes."
  }
]